{"ast":null,"code":"import { VOID, PRIMITIVE, ARRAY, OBJECT, DATE, REGEXP, MAP, SET, ERROR, BIGINT } from './types.js';\nconst EMPTY = '';\nconst {\n  toString\n} = {};\nconst {\n  keys\n} = Object;\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value) return [PRIMITIVE, type];\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n    case 'DataView':\n      return [ARRAY, asString];\n  }\n  if (asString.includes('Array')) return [ARRAY, asString];\n  if (asString.includes('Error')) return [ERROR, asString];\n  return [OBJECT, asString];\n};\nconst shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === 'function' || type === 'symbol');\nconst serializer = (strict, json, $, _) => {\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n  const pair = value => {\n    if ($.has(value)) return $.get(value);\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE:\n        {\n          let entry = value;\n          switch (type) {\n            case 'bigint':\n              TYPE = BIGINT;\n              entry = value.toString();\n              break;\n            case 'function':\n            case 'symbol':\n              if (strict) throw new TypeError('unable to serialize ' + type);\n              entry = null;\n              break;\n            case 'undefined':\n              return as([VOID], value);\n          }\n          return as([TYPE, entry], value);\n        }\n      case ARRAY:\n        {\n          if (type) {\n            let spread = value;\n            if (type === 'DataView') {\n              spread = new Uint8Array(value.buffer);\n            } else if (type === 'ArrayBuffer') {\n              spread = new Uint8Array(value);\n            }\n            return as([type, [...spread]], value);\n          }\n          const arr = [];\n          const index = as([TYPE, arr], value);\n          for (const entry of value) arr.push(pair(entry));\n          return index;\n        }\n      case OBJECT:\n        {\n          if (type) {\n            switch (type) {\n              case 'BigInt':\n                return as([type, value.toString()], value);\n              case 'Boolean':\n              case 'Number':\n              case 'String':\n                return as([type, value.valueOf()], value);\n            }\n          }\n          if (json && 'toJSON' in value) return pair(value.toJSON());\n          const entries = [];\n          const index = as([TYPE, entries], value);\n          for (const key of keys(value)) {\n            if (strict || !shouldSkip(typeOf(value[key]))) entries.push([pair(key), pair(value[key])]);\n          }\n          return index;\n        }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP:\n        {\n          const {\n            source,\n            flags\n          } = value;\n          return as([TYPE, {\n            source,\n            flags\n          }], value);\n        }\n      case MAP:\n        {\n          const entries = [];\n          const index = as([TYPE, entries], value);\n          for (const [key, entry] of value) {\n            if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry)))) entries.push([pair(key), pair(entry)]);\n          }\n          return index;\n        }\n      case SET:\n        {\n          const entries = [];\n          const index = as([TYPE, entries], value);\n          for (const entry of value) {\n            if (strict || !shouldSkip(typeOf(entry))) entries.push(pair(entry));\n          }\n          return index;\n        }\n    }\n    const {\n      message\n    } = value;\n    return as([TYPE, {\n      name: type,\n      message\n    }], value);\n  };\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\nexport const serialize = (value, {\n  json,\n  lossy\n} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map(), _)(value), _;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}